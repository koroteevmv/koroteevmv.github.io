---
section: os
title: "Управление процессами"
---


### Что такое процесс?



{% capture notice-2 %}
Выводы:
1. Процесс - это программа, запущенная на выполнение в оперативной памяти.
2. Одна программа может порождать несколько процессов.
3. Одну программу можно запустить несколько раз, и это будут разные процессы.
4. Все процессы выполняются независимо друг от друга, они изолированы операционной системой.
5. У каждого процесса есть свой выделенный участок памяти, в память других процессов ему доступ запрещен.
{% endcapture %}
<div class="notice--info">{{ notice-2 | markdownify }}</div>


### Что такое многозадачность?

{% capture notice-2 %}
Выводы:
1. В каждый момент в операционной системе выполняется множество процессов.
2. На одном ядре ЦП может выполняться только одна последовательность инструкций одновременно.
3. Операционная система постоянно переключает процессы на выполнение.
4. Иногда переключение происходит добровольно, но чаще - нет.
5. Сам процесс не имеет контроля над тем, когда его переключат.
6. Большинство современных операционных систем реализуют вытесняющую многозадачность.
{% endcapture %}
<div class="notice--info">{{ notice-2 | markdownify }}</div>

### В каких состояниях может находиться процесс?

{% capture notice-2 %}
Выводы:
1. Создание нового процесса - довольно длительный для компьютера процесс.
2. После создания процесс в состоянии готовности становится в очередь.
3. Когда очередь подходит, он начинает выполняться на процессоре.
4. Если во время выполнения процесс завершается, ОС его уничтожает и очищает память.
5. Если во время выполнения проходит квант времени, ОС опять ставит его в очередь.
6. Если во время выполнения процесс блокируется, ОС его приостанавливает. 
7. Когда придет внешнее событие, разблокирующее процесс, он опять становится в состояние готовности.
8. Существует много разных реализаций очереди процессов, с приоритетами и без.
{% endcapture %}
<div class="notice--info">{{ notice-2 | markdownify }}</div>

### Какую информацию ОС хранит о процессе?

{% capture notice-2 %}
Выводы:
1. У каждого процесса есть численный идентификатор.
2. С каждым процессом связан пользователь-владелец.
3. У каждого процесса (за исключением одного) есть процесс-родитель.
4. ОС хранит информацию о процессах в специальном разделе - файловой системе /proc.
5. ОС запоминает статистическую информацию о потреблении процессами ресурсов.
6. Большая часть информации о процессах скрыта. Например, открытые файловые дескрипторы.
{% endcapture %}
<div class="notice--info">{{ notice-2 | markdownify }}</div>

### Как процессы связаны с терминалами?

{% capture notice-2 %}
Выводы:
1. Каждый процесс при запуске связывается с определенным терминалом.
2. Это может быть виртуальный терминал, графическая программа или эмулятор.
3. Это связывание используется для разделения потоков ввода-вывода.
4. При запуске процесса терминал блокируется.
5. Некоторые процессы не связаны с терминалами.
{% endcapture %}
<div class="notice--info">{{ notice-2 | markdownify }}</div>

### Как посмотреть выполняемые процессы?

{% capture notice-2 %}
Выводы:
1. Самая распространенная команда - ps. 
2. По умолчанию она показывает только процессы текущего пользователя, связанные с текущим терминалом.
3. Полный список процессов можно посмотреть командой ps aux.
4. Интерактивную информацию о процессах показывает программа top.
5. Существует улучшенный вариант top - htop.
6. С помощью htop можно проводить полноценный мониторинг системы, выполнять операции над процессами.
{% endcapture %}
<div class="notice--info">{{ notice-2 | markdownify }}</div>

### Что такое процессы-демоны?

{% capture notice-2 %}
Выводы:
1. Демоны не связаны с терминалами и не имеют пользовательского интерфейса.
2. Они используются для выполнения фоновых операций.
3. Большинство демонов - системные службы.
4. Можно создать свою собственную программу-демона.
5. Существует специальная программа для управления службами.
{% endcapture %}
<div class="notice--info">{{ notice-2 | markdownify }}</div>

### Как снять процесс?

{% capture notice-2 %}
Выводы:
1. Завершить текущий процесс в терминале можно комбинацией Ctrl + C.
2. Интерактивные программы нужно стараться завершать штатно.
3. Снять индивидуальный процесс можно с помощью программы kill.
4. Формально, это послание сигнала процессу.
5. Для мягкого завершения используется сигнал 15.
6. Для того, чтобы снять зависший процесс может понадобится сигнал 9.
7. Убить все процессы по имени команды можно командой killall.
{% endcapture %}
<div class="notice--info">{{ notice-2 | markdownify }}</div>

### Как связаны родитель и потомок?

{% capture notice-2 %}
Выводы:
1. Для каждого процесса, кроме самого первого существует процесс-родитель.
2. Поэтому процессы в Linux образуют дерево.
3. При завершении родителя, все его потомки тоже завершаются.
4. Процесс наследует от родителя пользователя и права доступа.
5. В редких случаях пользователь может измениться.
{% endcapture %}
<div class="notice--info">{{ notice-2 | markdownify }}</div>

### Что такое приоритет процесса?

{% capture notice-2 %}
Выводы:
1. Приоритет процесса - это число, определяющее, как часто процесс будет получать процессорное время.
2. В Linux также используется число nice value - величина, обратная приоритету.
3. Nice измеряется от -20 (высший приоритет) до 19 (низший приоритет).
4. Пользователь может понизить приоритет своих процессов.
5. Повысить приоритет может только суперпользователь.
6. Можно запустить процесс с нестандартным приоритетом командой nice -n. 
7. Можно изменить приоритет уже выполняемого процесса командой renice -n.
8. Эти команды задают числа, которые прибавляются к nice value.
{% endcapture %}
<div class="notice--info">{{ notice-2 | markdownify }}</div>

### Что такое фоновые процессы?

{% capture notice-2 %}
Выводы:
1. Можно запустить процесс без привязки к терминалу, в фоновом режиме с помощью &.
2. Если мы хотим перевести процесс в состояние остановленный, используется сочетание клавиш «Ctrl + z».
3. Можем переместить остановленный процесс на передний план командой fg.
4. Можно продолжить выполнение остановленного процесса в фоновом режиме командой bg.
5. Используя команду jobs мы можем получить список остановленных и фоновых процессов.
{% endcapture %}
<div class="notice--info">{{ notice-2 | markdownify }}</div>